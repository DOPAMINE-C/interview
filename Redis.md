# 一. 常识

 

## 1. 简述 `Redis`

简单来说 **`Redis `就是一个使用 C 语言开发的数据库**，不过与传统数据库不同的是 **`Redis `的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此**` Redis `被广泛应用于缓存方向**。





## 2. `Redis`与传统数据库的区别

**`Redis`是一种基于键值对的`NoSQL`数据库。**数据都存储于**内存**中,性能更好。

关系型数据库是基于二维数据表来存储数据的。关系型数据库的数据存储于**磁盘**上，但性能不好。





##  3. 为何要使用`Redis`/缓存？

拥有“更高的性能”和“更高的并发”。

![img](https://snailclimb.gitee.io/javaguide/docs/database/redis/images/redis-all/%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E4%B9%8B%E5%90%8E.png)





# 二. `Redis`



## 1. `Redis`有哪些数据类型？

- `Redis`支持5种核心的数据类型，分别是String、哈希、List列表、Set集合、`Zset`有序集合；

  > - 除了**字符串类型有自己独有设置过期时间的命令 `setex`   <key><过期时间><value>**  外，其他方法都需要依靠 `expire` 命令来设置过期时间
  >
  >   > expire message 60
  >
  > - **字符串类型 的 命令 `SETNX `<key><value>只有在 key 不存在时   设置 key 的值 ， 可用于`Redis` 设置分布锁。**
  >
  > - **和 set 相比，`Zset `增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列**

- `Redis`还提供了Bitmap、`HyperLogLog`、Geo类型，但这些类型都是基于上述核心数据类型实现的；

  > - `HyperLogLog` : 用于统计大规模数据。
  > - Geo ： Geographic，用于处理地理位置信息。。

- `Redis`在5.0新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。



### `bitmap`

 **Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value）** ， 但是它**可以对字符串的位进行操作**。可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。

> 每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。
>
> - 注：
>
>   很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做  `setbit`  操作时将用户id减去这个指定数字。

- **应用场景：** 适合需要**保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。**比如用户签到情况、活跃用户情况

Bit-map的基本思想就是**用一个bit位来标记某个 key 对应的Value。**由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。（PS：划重点 **节省存储空间**）,如图：

![image-20220315110911123](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220315110911123.png)

**每一位表示一个 key，0表示不存在，1表示存在**，这正符合二进制。

![img](https://img2018.cnblogs.com/blog/874963/201909/874963-20190930161508728-1545815203.png)



#### 常用命令：

- `setbit` ： <key><offset><value>设置Bitmaps中某个偏移量的值（0或1）

- `getbit`：<key><offset>获取Bitmaps中某个偏移量的值

- `bitcount`：<key>[start end] 统计字符串从start字节到end字节比特值为1的数量

- `bitop` ：(and/or/not 非/xor 异或) <destkey> [key…]   复合操作后将结果保存在destkey中

  > 如 ： 计算出两天都访问过网站的用户数量
  >
  > ​	bitop    and    unique:users:and:20201104_03  unique:users:20201103  unique:users:20201104
  >
  > ​				 操作            destkey                                                key1                                     key2

```redis
127.0.0.1:6379> setbit mykey 7 1
(integer) 0
127.0.0.1:6379> setbit mykey 7 0
(integer) 1
127.0.0.1:6379> getbit mykey 7
(integer) 0
127.0.0.1:6379> setbit mykey 6 1
(integer) 0
127.0.0.1:6379> setbit mykey 8 1
(integer) 0
# 通过 bitcount 统计被被设置为 1 的位的数量。
127.0.0.1:6379> bitcount mykey
(integer) 2
```

 



## 2. `Redis`单线程模型

**`Redis `是单线程+多路IO复用**

> `redis`是通过IO多路复用来处理多个客户端请求的,但**由于是单线程，所以同一时刻只可以处理一个客户端请求**

### 为何采用单线程？/`Redis`为何这么快？

- **`Redis `的性能瓶颈不在 CPU ，主要在内存和网络**

- **单线程可以避免不必要的线程上下文切换和性能消耗。**多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能

- **完全基于内存**，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于`HashMap`，`HashMap`的优势就是查找和操作的时间复杂度都是O(1)；

- 使用多路I/O复用模型。多路 I/O 复用技术可以让单个线程高效的处理多个连接请求。

  > “多路”指的是多个网络连接，**“复用”指的是复用同一个线程**。
  >
  > - 多路复用：**在线程空闲的时候，会将其阻塞掉**，当有一个或多个流**有 I/O 事件时**，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，并且只**按顺序的处理就绪的I/O流，这种做法就避免了大量的无用操作。**







## 3. `Redis`事务 : 不支持回滚

> **`Redis`事务**和关系型数据库不同，它**不支持回滚**。

`Redis` 可以通过 **`MULTI`，`EXEC`，`DISCARD` 和 `WATCH`** 等命令来实现  事务(transaction)  功能。

- **`MULTI`: 用于开启一个事务**。使用 `MULTI`命令后可以输入多个命令。`Redis` 不会立即执行这些命令，而是**将它们放到队列**，当调用了 `EXEC`命令将执行所有命令。
- `EXEC`:  执行所有事务块内的命令。
- `DISCARD`:  取消一个事务，它会清空事务队列中保存的所有命令
- **`WATCH`:  用于监听指定的键**，可以监控一个或多个键，**一旦被监听的键被修改，之后的事务就不会执行，直接返回失败**。**监听一直持续到`EXEC`命令**。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220317101723325.png" alt="image-20220317101723325" style="zoom:50%;" />





## 4. `Lua`脚本 : 原子性,解决超卖

利用 `Lua `脚本可以**解决多任务并发问题**。

实际上是`redis` 利用其单线程的特性，用任务队列的方式解决多任务并发问题。

- `Lua`脚本的作用：**将**复杂的或者**多步的`redis`操作**，**写为一个脚本，一次提交给`redis`执行**，**减少反复连接`redis`的次数**，提升性能。**`Lua`脚本在执行时不会被其他命令插队，即具有原子性**
- 利用`lua脚本`可以淘汰用户，解决超卖问题。









# 三. 重点问题



## 1. `Memcache`与`Redis`的区别都有哪些？

`Memcache` ： **不支持数据持久化，只支持键值对类型的数据，多线程，不支持订阅发布**。

分布式缓存的话，使用的比较多的主要是 `Memcached` 和 `Redis`。

> - 集群：很多“人”一起 ，干一样的事。 
> - 分布式：很多“人”一起，干不一样的事

**共同点** ：

1. **都是基于内存的数据库，一般都用来当做缓存使用**。
2. **都有过期策略**。
3. 两者的性能都非常高。

**区别** ：

1. **`Redis` 支持更丰富的数据类型（支持更复杂的应用场景）**。`Redis` 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，`zset`，hash 等数据结构的存储。**`Memcached `只支持最简单的键值对数据类型。**

2. **`Redis` 支持数据的持久化，而 `Memcached` 把数据全部存在内存之中。**

   > `Redis`支持两种不同方式的持久化。

3. **`Memcached `是多线程，非阻塞 IO 复用的网络模型；`Redis` 使用单线程的多路 IO 复用模型。** 

   > - 阻塞IO: 调用IO时，如果没有数据收到，那么线程或者进程就会被挂起，直到收到数据。阻塞的意思，就是一直等着。
   > - 非阻塞IO ：调用IO时，如果没有数据收到，就立刻返回一个错误。不会一直等待。
   >
   > - 多路复用：文件就绪后，可以在同一个线程中进行操作。

4. **`Redis` 支持发布订阅模型、`Lua` 脚本、事务等功能，而` Memcached` 不支持。并且，`Redis` 支持更多的编程语言。**

5. **`Memcached` 过期数据的删除策略只用了惰性删除，而 `Redis `同时使用了惰性删除与定期删除。**





## 2. `redis`的数据类型，以及每种数据类型的使用场景

### String

- string 数据结构是**简单动态字符串**(Simple Dynamic String,缩写`SDS`)。**是可以修改的字符串**。采用**预分配空间的方式来减少内存的频繁分配**。

  - 如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度` len`。当字符串长度小于1 M时，扩容都是加倍现有的空间，如果超过1 M，扩容时一次只会多扩1 M的空间。需要注意的是字符串最大长度为512 M。

    ![image-20220315164152671](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220315164152671.png)

- **应用场景：** 一般常用在**需要计数的场景**，比如**用户的访问次数、热点文章的点赞转发数量**等等。

  > `incr/decr` : 将 key 中储存的数字值增/减 1  ；` incrby/decrby`<key><步长> : 将 key 中储存的数字值增减。自定义步长。



### List

> 元素少时，用压缩列表`ziplist` ； 元素多时，将多个`ziplist`使用双向指针串起来变成快速列表`quicklist`。

- 底层是**快速列表`quickList`**，可以添加一个元素到列表的头部（左边）或者尾部（右边）。

  - 在列表元素较少的情况下会使用一块连续的内存存储，这个结构是`ziplist`，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成`quicklist`。**`Redis`将链表和`ziplist`结合起来组成了`quicklist`。也就是将多个`ziplist`使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。**

    ![image-20220315164440913](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220315164440913.png)

- 特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。

- **应用场景:** 发布与订阅或者说**消息队列**、慢查询。





### Hash

> 数据结构类似 List

- 数据结构
  - `zipList` 压缩列表：元素少时，将所有的元素紧挨着一起存储，分配的是一块连续的内存。
  - `hashtable` ：元素多时，使用





### `Zset`

- 和 set 相比，**`Zset `增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列**

  > set  无序，不可重复

- `zset `底层使用了两个数据结构

  - **Hash** ,**hash的作用就是关联元素value和权重score**，**可以通过元素value找到相应的score值**。

    > 如图，hash表中 中field 放的是元素的 value，value 放的是 score

    <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220317104948259.png" alt="image-20220317104948259" style="zoom:50%;" />

  - **跳跃表**，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。

    > 跳跃表：分层查找，这一层找不到就往下一层找。
    >
    > <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220317103021934.png" alt="image-20220317103021934" style="zoom:50%;" />

- 需要**对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜**





## 3. `redis`的过期删除策略以及内存淘汰机制

### (1) 过期删除策略

- **因为内存有限，若缓存数据一直保存，则会引发`OOM`。所以设置缓存数据的过期时间是必要的。**
- 常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：
  - **惰性删除** ：key过期的时候不删除，**只会在数据库取出 key 的时候才进行过期检查**。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
  - **定期删除** ： **每隔一段时间执行删除过期 key 操作**。并且，`Redis` 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 `Redis `采用的是 **定期删除+惰性删除** 。

但是，仅仅通过给 key 设置过期时间还是有问题的。因为**还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况**。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。

怎么解决这个问题呢？答案就是：**内存淘汰机制。**



### (2)内存淘汰机制(了解)

`Redis` 提供 6 种数据淘汰策略：

1. **volatile-`lru`（least recently used）**：从已设置过期时间的数据集（`server.db[i].expires`）中挑选最近最少使用的数据淘汰
2. **volatile-`ttl`**：从已设置过期时间的数据集（`server.db[i].expires`）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（`server.db[i].expires`）中任意选择数据淘汰
4. **`allkeys-lru`（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **`allkeys-random`**：从数据集（`server.db[i].expires`）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！



## 4. `Redis`持久化机制

`Redis `不同于 `Memcached `的很重要一点就是，`Redis `支持持久化，而且支持两种不同的持久化操作。**`Redis `的一种持久化方式叫`RDB`持久化（`Redis` Database，`RDB`），另一种方式是`AOF`持久化（只追加文件 append-only file, `AOF`）**  解决持久化的实时性。

- `RDB`持久化 : **是`Redis`默认的持久化方式。它以快照的形式将数据持久化到硬盘中。**`Redis` **创建快照之后，可以对快照进行备份**，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（`Redis` 主从结构，主要用来提高 `Redis` 性能），还可以将快照留在原地以便重启服务器的时候使用。

  - `RDB`持久化的实现原理：

    （1）**`Redis `  fork 一个子进程。**

    （2）父进程继续接收并处理客户端发来的命令，而**子进程开始将内存中的数据写入硬盘中的`RDB`临时文件**。

    （3）当子进程写入完所有数据后会用新的`RDB`临时文件替换旧的`RDB`文件，至此，**一次快照操作完成**。

    <img src="https://pic3.zhimg.com/80/v2-c2fa3f19db14b94aeb3fe40b88fb5b1a_720w.jpg" alt="img" style="zoom: 67%;" />

- `AOF`持久化 ：**解决了数据持久化的实时性，是目前`Redis`持久化的主流方式。`AOF`以独立日志的方式，记录了每次写命令，重启时再重新执行`AOF`文件中的命令来恢复数据。**`AOF`的工作流程包括：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load），如下图：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694957486/72D05C716050D5C022C41B7911FAED6D)





## 5. 缓存与数据库的一致性问题

### （1）单机系统下 如何保证`Mysql `与 `Redis`的一致性?

​	采用 Cache Aside Pattern（旁路缓存模式），**即 先更新数据库，再删除旧缓存。**

- **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。

- **命中**：应用程序从cache中取数据，取到后返回。

- **更新(重点)**：先更新数据库，再删除旧缓存。

  

如果更新数据库成功，而**删除缓存这一步失败**的情况的话：

- **增加 缓存 更新重试机制（常用）**： 如果缓存失效而 导致缓存删除失败的话，我们就**隔一段时间进行重试**，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。



### （2）集群环境下，如何保证缓存与数据库的一致性？

- 在集群环境下，`mysql`采用读写分离模式，要保证`Mysql `与 `Redis`的数据一致性，需要在`主数据库`和`Redis`之间**增加一个`binlog`订阅系统**，**先**记录`主数据库`中更新的缓存数据，**再将**最新的数据更新到`Redis`中。

  > `Mysql`读写分离：
  >
  > - **主数据库 可以进行读写操作**，数据更新时 同步到 从数据库 ；
  >
  > - **从数据库是只读的**，接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而**一个从数据库只能有一个主数据库。**

  - 若想**增加 系统的高可用性**，针对 缓存更新失败的问题，可以**增加一个消息队列**，存放更新失败的缓存数据，等到系统正常后再更新到`redis`中。



产生缓存与数据库不一致的原因：

- 在`Mysql`读写分离（主从架构）中，由于网络问题，`从数据库`没有及时从`主数据库`读取最新的数据，又由于是读写分离的架构，**读请求**会在发现`Redis`为空后，**只能在`从数据库`中查询数据**，但此时`从数据库`中的为旧数据，所以`Redis`也更新为旧数据，在网络正常后，会导致缓存和数据库数据不一致的问题。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316112141133.png" alt="image-20220316112141133" style="zoom:67%;" />

- 解决办法：**增加一个`binlog`订阅系统**

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316113243174.png" alt="image-20220316113243174" style="zoom: 33%;" />

- **如果订阅系统向`Redis`更新缓存失败的话，增加系统高可用性，即增加一个消息队列**：
  - 把当前更新失败的 缓存数据 按序 存入消息队列中，等缓存服务可用之后，再将消息队列中的数据按序更新到订阅系统和`Redis`中。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316113831659.png" alt="image-20220316113831659" style="zoom:50%;" />







## 6. 实现`Redis`高可用

**实现`Redis`的高可用，主要有哨兵和集群两种方式。**

### `Redis`主从复制

- 主从复制，是指**将一台`Redis`服务器的数据，复制到其他的`Redis`服务器。前者称为主节点(master)，后者称为从节点(slave)**；数据的复制是单向的，只能由主节点到从节点。默认情况下，每台`Redis`服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但**一个从节点只能有一个主节点**。

- **读写分离**,主(master)以写为主，从(slave)以读为主。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316160855287.png" alt="image-20220316160855287" style="zoom: 50%;" />

### （1）哨兵模式：实现了高可用，读写分离

**反客为主的自动版**，**能够后台监控主机是否故障，如果故障了根据投票数自动将 从库(slave) 转换为 主库(master)**

> 反客为主模式：当一个master故障后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316162240361.png" alt="image-20220316162240361" style="zoom:50%;" />

- 原理：`Redis Sentinel`（哨兵）是一个分布式架构，它**包含若干个哨兵节点和数据节点**。**每个哨兵节点会对数据节点和其余的哨兵节点进行监控，当发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它就会与其他的哨兵节点进行协商，当多数哨兵节点都认为主节点不可达时，它们便会选举出一个哨兵节点成为新的主节点，同时还会将这个变化实时地通知给应用方。**整个过程是自动的，不需要人工介入，有效地解决了`Redis`的高可用问题！

  一组哨兵可以监控一个主节点，也可以同时监控多个主节点，两种情况的拓扑结构如下图：

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316162551210.png" alt="image-20220316162551210" style="zoom: 67%;" />



### （2）集群

**在哨兵模式下，每台 `Redis `服务器都存储相同的数据，很浪费内存**，所以在`redis3.0`上加入了 Cluster 集群模式，实现了` Redis` 的分布式存储，也就是说**每台 `Redis `节点上存储不同的内容。**

- **利用`Redis`集群模式，可以做到在多台机器上部署多个`redis`实例，每个实例存储一部分的数据，同时每个`redis`实例可以挂载 `redis`从实例，如果`redis`主实例 故障了，会自动切换到 `redis`从实例。**



#### 集群的分片机制：

**`redis`集群 采用 哈希槽 来实现数据分片。**

- **哈希槽**：`redis`集群有固定的16384个hash slot，对每个key计算`CRC16`值，然后对16384取模，**通过公式计算可以获取key对应的 哈希槽**

> 计算公式为slot= `CRC16` (key)&16383

**`redis` 集群中每个 主节点(master) 都会持有部分哈希槽和哈希槽对应的键值数据。**

> 比如有3个master，那么可能每个master持有5000多个hash slot

<img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694995647/2B3170169B19552123C5487746142DF6" alt="img" style="zoom: 67%;" />

#### 集群环境下，缓存和数据库的一致性问题

见 5.2





## 7. 缓存高并发场景

### （1）缓存穿透

缓存穿透说简单点就是大量请求的 **key 根本不存在于缓存中**，导致**请求直接到了数据库上，根本没有经过缓存这一层**。

> 举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316182549910.png" alt="image-20220316182549910" style="zoom:67%;" />

解决办法：

- **布隆过滤器**：**布隆过滤器可以用很低的代价，找到数据是否存在于海量数据中**
  - **先**把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，**先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。**

<img src="https://snailclimb.gitee.io/javaguide/docs/database/redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="img" style="zoom: 80%;" />

- **对空值缓存：**就算对数据库的查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟



### （2）缓存击穿

在高并发场景下，大量的用户请求某个非常热点的 缓存key，当此**热点 缓存key失效时**，这些请求会打到数据库上，从而压垮数据库。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316182525309.png" alt="image-20220316182525309" style="zoom: 67%;" />

解决方法：key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。

- **预先设置热门数据：**在`redis`高峰访问之前，把一些热门数据提前存入到`redis`里面，**加大这些热门数据key的时长**
- **加互斥锁**：在缓存失效的时候（判断拿出来的值为空），**对数据库的访问加互斥锁，只有一个线程可以抢到锁，即只有一个线程能操作数据库，从而数据库压力很小。该线程查询到数据过后，更新缓存，其他线程在没抢到数据库的锁时睡一会儿，在`Redis`更新后再去缓存中查询。**



### （3）缓存雪崩

> 缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，缓存击穿则是某一个key

高并发场景下，**大量的缓存key，在同一时间失效**。请求都直接落到了数据库上，像雪崩一样压垮了数据库。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316185957225.png" alt="image-20220316185957225" style="zoom:50%;" />

解决方法：

- **随机设置缓存失效时间**：设置过期时间时，附加一个随机数，**避免大量的key同时过期**。
- **`redis`集群部署**：**把热点的缓存key，放到不同的`redis`节点上，个别节点宕机，依然可以保持服务的整体可用**。





## 8. `Redis`分布式锁

​	在分布式的环境下，当多个server并发修改同一个资源时，为了避免竞争就需要使用分布式锁。

- 什么是分布式锁？

  分布式锁可以在分布式环境下，控制不同机器对共享资源的访问。

**`Redis`中可以使用`SETNX`命令实现分布式锁。** **即 当`SETNX`返回 1，进程才能获得锁。**

> `SETNX`: set if not exists，
>
> - 只在键 `key` 不存在的情况下， 将键 `key` 的值设置为 `value` 。 
>   - 当 key 的值被设置时，返回 1 。**说明该进程获得锁**
>
> - 若键 `key` 已经存在， 则 `SETNX` 命令不做任何动作。
>   - 当 key 的值没被设置时，返回 0 。**说明其他进程已经获得了锁**

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220316192654476.png" alt="image-20220316192654476" style="zoom: 80%;" />
