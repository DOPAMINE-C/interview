# 0.前言

`SQL` ： Structure Query Language(结构化查询语言)



## 1.主键和外键的区别

- **主键(主码)** ：**主键用于唯一标识一个行，不能有重复，不允许为空。一个表只能有一个主键。**

- **外键(外码)** ：外键用来和其他表建立联系用，**外键是 别的表 的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。**

  ```
  说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。
  ```

​		其中：元组（tuple）是关系型数据库中的基本概念，**表中的每行（即数据库中的每条记录）就是一个元组**，每列就是一个属性。 在二维表里，**元组也称为行**。







## 2. drop、delete 与 truncate 区别？

- drop(丢弃数据): `drop table 表名` ，**直接将表都删除掉**，在删除表的时候使用。
- truncate (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- delete（删除数据） : `delete from 表名 where 列名=值`，**删除某一列的数据**，如果不加 where 子句和`truncate table 表名`作用类似。

truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 **truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。**





## 3. `SQL`的分类

1、`DDL`(Data Definition Language) 数据定义语言，用来操作数据库、表、列等； 常用语句：CREATE、 ALTER、DROP
2、`DML`(Data Manipulation Language) 数据操作语言，用来操作数据库中表里的数据；常用语句：INSERT、 UPDATE、 DELETE
3、`DCL`(Data Control Language) 数据控制语言，用来操作访问权限和安全级别； 常用语句：**GRANT、DENY**
4、`DQL`(Data Query Language) 数据查询语言，用来查询数据 常用语句：SELECT





## 4. 数据库的三大范式

1、**第一范式**   ：  是指数据库表的每一列都是不可分割的基本数据线；也就是说：**每列的值具有原子性，不可再分割**。
2、**第二范式**   ：  是在第一范式的基础上建立起来得，满足第二范式必须先满足第一范式。如果表是单主键，那么**主键以外的列必须完全依赖于主键**；如果表是复合主键，那么主键以外的列必须完全依赖于主键，不能仅依赖主键的一部分。
3、**第三范式**   ：  是在第二范式的基础上建立起来的，即满足第三范式必须要先满足第二范式。第三范式要求：**表中的非主键列必须和主键直接相关而不能间接相关**；也就是说：非主键列之间不能相关依赖。





## 5.关系型数据库与非关系型数据库

1. 关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。

​	关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。

​	并且，大部分关系型数据库都支持**事务的四大特性(ACID)**。

> 原子性、一致性、隔离性、持久性。

2. NoSQL : 不保证关系数据的ACID特性









# 一. MySQL



## 1. MySQL的存储引擎

1. `Myisam` ：MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎。**MyISAM 不支持事务  ,  行级锁  ,  外键**  ，**不支持数据库异常崩溃后的安全恢复**。
2. `InnoDB`： 5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），也就是说 `InnoDB` 支持事务  ,  行级锁  ,  外键   ，**支持数据库异常崩溃后的安全恢复**。 



​	解释：（1）**不支持行级锁：也就说，MyISAM 一锁就是锁住了整张表**，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 	在并发写的时候，性能更牛皮了！

​				（2）InnoDB **提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。**

​				（3）使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。

​				（4）MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来**保证事务的隔离性**（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。

​						**MVCC 多版本并发控制， 是基于 “数据版本” 对并发事务进行访问的， RC,RR 通过 MVCC 保证事务的隔离性。**是一种对乐观锁的实现

​						MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。







## 2. 事务

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**



### 2.1 数据库事务

平时，我们在谈论事务的时候，如果没有特指**分布式事务**，往往指的就是**数据库事务**。



**数据库事务的作用？**

数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些操作遵循：**要么全部执行成功,要么全部不执行** 。

```sql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```

![img](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/640-20201207160554677.png)



### 2.2 事务的四大特性：ACID

![事务的特性](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png)

1. **原子性**（`Atomicity`） ： **事务是最小的执行单位，不允许分割。**事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： **执行事务前后，数据保持一致**，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，**一个用户的事务不被其他事务所干扰**，各并发事务之间数据库是独立的；
4. **持久性**（`Durability`）： 一个事务被**提交之后**。它**对数据库中数据的改变是持久的**，即使数据库发生故障也不应该对其有任何影响。



#### **数据事务的实现原理:** (重)

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的**隔离性**（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。

保证了事务的持久性、原子性、隔离性之后，**一致性**才能得到保障。





### 2.3 并发事务产生的问题

多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。



- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种**修改还没有提交到数据库中**，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么**另外一个事务读到的这个数据是“脏数据”**，依据“脏数据”所做的操作可能是不正确的。

  > 简述：一个事务读到了另一个事务修改完还未提交的数据。

- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样**第一个事务内的修改结果就被丢失**，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。

  > 简述：在并发事务中，某一个事务的修改丢失，即未被提交。

- **不可重复读（Unrepeatable read）:** 在事务A中先后两次读取同一个数据，**两次读取的结果不一样**，这种现象称为不可重复读。

  > 查询**结果**不一样

- **幻读（Phantom read）:** 幻读与不可重复读类似。在事务A中按照某个条件先后两次查询数据库，**两次查询结果的条数不同**，这种现象称为幻读。

  > 查询**条数**不一样







### 2.4 事务的隔离级别

 MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。

InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √    | √          | √    |
| READ-COMMITTED   | ×    | √          | √    |
| REPEATABLE-READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |



- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** **最高的隔离级别**，完全服从 ACID 的隔离级别。**所有的事务依次逐个执行(串行执行)**，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

![image-20220313190109104](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220313190109104.png)







## 3. 索引

**索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。**索引的作用就相当于目录的作用。



### （1）索引的底层实现 

在MySQL中，索引是在存储引擎层实现的，**不同存储引擎对索引的实现方式是不同的**



1. 为何不采用`Hash`表作为索引的数据结构？

​		**1.Hash 冲突问题** (不同数据计算出的`hash`值相同)

​		**2.Hash 索引不支持顺序和范围查询  (Hash 索引不支持顺序和范围查询是它最大的缺点 )**



2. **B 树& B+树两者有何异同呢？**

   B 树也称 B-树,全称为 **多路平衡查找树** ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。

   

   - **B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。**

   - **B 树的叶子节点都是独立的**    ;    **B+树的叶子节点有一条引用链指向与它相邻的叶子节点。**

   - **B 树的检索的过程中存在 回溯查找的问题。而 B+树的叶子节点间有链表连着，解决了需要回溯查找的问题。**



​	3.  在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。

​			(1) MyISAM 引擎中，**索引文件和数据文件是分离的**，索引文件仅保存数据记录。B+Tree **叶节点的 data 域存放的是数据记录的地址。**这被称为“非聚集索引”。<img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645693101962/911E67ED440AC5388F07D79E4988BD69" alt="img" style="zoom: 33%;" />

​			

​			(2) InnoDB 引擎中，**其数据文件本身就是索引文件**。B+Tree  **叶节点包含了完整的数据记录**。这被称为聚集索引。

<img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645693148945/E93917AAC699168036AF5C36393FFC04" alt="img" style="zoom: 33%;" />





### （2）索引类型

#### 1.主键索引(Primary Key)

**数据表的主键列使用的就是主键索引。**

一张数据表有**只能有一个主键，并且主键不能为 null，不能重复**。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 自增主键。



#### 2. 二级索引(辅助索引)

**二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**

一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引。

> 例如：首先通过二级索引树中找到Java对应的主键id为 “16”（读取2个磁盘块）。然后在去主键索引中查找id为“16” 的数据（读取3个磁盘块）。

![index2.png](http://www.mybatis.cn/usr/uploads/2020/07/3458883581.png)

![index1.png](http://www.mybatis.cn/usr/uploads/2020/07/2650273189.png)





#### 3. 聚集索引与非聚集索引

​		**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**

​		InnoDB 引擎中，**其数据文件本身就是索引文件**。所以对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。属于聚集索引。

​		优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，**叶子节点也都是有序的**，定位到索引的节点，就相当于定位到了数据。

​		缺点：1.依赖有序的数据    2.更新代价大



​		**非聚集索引即索引结构和数据分开存放的索引。**二级索引属于非聚集索引。

​		MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和数据记录的地址。属于非聚集索引。

​		优点：更新代价小。非聚集索引的叶子节点是不存放数据的

​		缺点：1.依赖有序数据   

​					2. **可能会二次查询(回表)** :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。



![img](https://img-blog.csdnimg.cn/20210420165326946.png)



#### 4.（重要）联合索引（多列索引）：联合索引遵循最左前缀原则。

**联合索引是指对表上的多个列进行索引，**从本质上来说，联合索引还是一棵B+树，不同的是**联合索引的键值数量不是1，而是大于等于2**，参考下图。另外，只有在查询条件中**使用了这些字段的左边字段时，索引才会被使用**，所以使用联合索引时遵循最左前缀集合。

**在使用组合索引的时候，如果没有遵从“最左前缀”的原则进行搜索，则索引是不起作用的。**

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645693387028/585E166E07C05C8308FBAD31D36FEEC3)

**尽可能的考虑建立联合索引而不是单列索引。**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。





#### 5. 全文索引

全文索引类型为`FULLTEXT`，在定义索引的列上**支持值的全文查找**，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。**解决判断字段是否包含的问题**。

 例如: 有title字段,需要查询所有包含 "政府"的记录. 需要 like "%政府%"方式查询,查询速度慢,当查询包含"政府" OR "中国"的需要时,sql难以简单满足.全文索引就可以实现这个功能.











### （3）`Mysql`如何为表字段添加索引

1.添加 PRIMARY KEY（主键索引）

```sql
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
```

2.添加 UNIQUE(唯一索引)

```sql
ALTER TABLE `table_name` ADD UNIQUE ( `column` )
```

3.添加 INDEX(普通索引)

```sql
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

4.添加 FULLTEXT(全文索引)

```sql
ALTER TABLE `table_name` ADD FULLTEXT ( `column`)
```

5.添加多列索引

```sql
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```





### （4）如何判断数据库的索引有没有生效？

可以**使用EXPLAIN语句查看索引是否正在使用**。

举例，假设已经创建了book表，并已经在其year_publication字段上建立了普通索引。执行如下语句：

```sql
EXPLAIN SELECT * FROM book WHERE year_publication=1990;
```

EXPLAIN语句将为我们输出详细的SQL执行信息，其中：

- possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。
- key行是MySQL实际选用的索引。

如果possible_keys行和key行都包含year_publication字段，则说明在查询时使用了该索引。





## 4. 锁

**数据库锁的类型：行级锁  &  表级锁。   具体实现：共享锁 & 排他锁**，**共享锁 & 排它锁都是悲观锁**的具象实现

**只有「明确」指定主键，才会执  行级锁，否则将会执行  表级锁**



### （1）InnoDB 锁算法（3）

#### 1. 行锁算法

InnoDB存储引擎有3种行锁的算法，其分别是：

- Record Lock（普通行级锁）：**行记录锁**，单个行记录上的锁。
- Gap Lock：**间隙锁**，锁定一个范围，但不包含记录本身。
- Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。



#### 2. 表锁算法

#####  意向锁

- 当一个事务带着表锁去访问一个被加了行锁的资源，那么，此时，这个行锁就会升级为意向锁，将表锁住。

- 常用的意向锁有：意向共享锁，意向排它锁，共享意向排它锁

##### 自增锁

- 事务插入自增类型的列时获取自增锁

  > 如果一个事务正在往表中插入自增记录，所有其他事务的插入必须等待





### （2）数据库锁的实现

#### 1.共享锁 & 排它锁

> 共享锁 & 排它锁都是悲观锁的具象实现

> 行锁和表锁是锁粒度的概念，共享锁和排它锁是他们的具体实现

##### 共享锁（S）share：读锁

- **允许一个事务去读一行，阻止其他事务获取该行的排它锁**。
- 多事务时，只能加共享读锁，不能加排他写锁；单事务时，可以加任何锁。
- 一般理解为：能读，不能写。

##### 排它锁（X）：写锁

- **允在某个事务获取数据的排它锁后，其他事务不能获取该数据的任何锁**。
- 其他事务不能获取该数据的任何锁，直到排它锁持有者释放。
- 不能获取任何锁，不代表不能无锁读取。

**<font color="red">注意</font>**

- 排它锁指的是，在某个事务获取数据的排它锁后，其他事务不能获取该数据的任何锁，
  **并不代表其他事务不能无锁读取该数据。**
  - <font color="red">无锁</font>
    - **select ... from**
  - <font color="red">共享锁</font>
    - **select ... lock in share mode**
  - <font color="red">排它锁</font>
    - **update**
    - **delete**
    - **insert**
    - **select ... for update**



#### 2 .乐观锁 & 悲观锁

##### 乐观锁

- 通过版本号来进行更新的操作属于乐观锁

  ```sql
  update tab set name = 'xxx' where id = 1 and version = xxx
  ```

##### 悲观锁

> 共享锁 & 排它锁都是悲观锁的具象实现

- 显示地控制行或表锁属于悲观锁



### （3）数据库死锁

死锁是指两个或两个以上的事务在执行过程中，因**争夺锁资源而造成的一种互相等待的现象**。

- 解决方法：

解决死锁问题最简单的一种方法是**设置超时时间**，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行**回滚**，另一个等待的事务就能继续进行。







# 二. 重点问题

 

## 1.  MySQL的索引为什么用B+树？

**在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。**

1. B+树能显著**减少IO次数**，提高效率。因为在数据库中，B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作。
2. B+树的**查询效率更加稳定，因为数据放在叶子节点**
3. B+树**能提高范围查询的效率，因为叶子节点指向下一个叶子节点**

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645693350499/FB148499A73DF0C97F7930BA0466170E)





## 2. 创建索引的注意事项

1. 索引并不是越多越好，因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。
2. **尽可能的考虑建立联合索引而不是单列索引。**使用联合索引，**多个字段在一个索引上**，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。
3. **被频繁更新的字段应该慎重建立索引。**虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。





## 3. MVCC机制：多版本并发控制

[【IT老齐030】这可能是最直白的MySQL MVCC机制讲解啦!_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hL411479T?from=search&seid=1626687517676590883&spm_id_from=333.337.0.0)

英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制。在 `InnoDB`引擎下，**RC,RR基于MVCC 进行并发事务控制 ， 即 是通过 MVCC 保证事务的隔离性的**。**MVCC 是基于 “数据版本” 对并发事务进行访问的。**

**并且   `MVCC `    在`innoDB`默认的隔离级别 `Repeatable Read` 下 实现了可重复读和防止部分幻读**。



**MVCC 在每次快照读时提取数据，照着 ReadView 判断某个版本的数据对当前事务是否可见，不可见的话，那就顺着 undo log版本链 找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。**

> InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。





### （1）MVCC的实现 ： 依赖于 ReadView + undo log版本链

> ReadView 是 快照读 SQL（Select语句） 执行时, MVCC 提取数据的依据。**ReadView 是一个数据结构**。MVCC照着 ReadView 来**判断某个版本的数据对当前事务是否可见**。
>
> 快照读：就是最普通的**Select**查询SQL**语句**；
>
> 当前读：读取的是数据的最新版本。执行insert,update,delete等语句时进行数据读取的方式。



- 什么是  **undo log版本链 ** 呢？
  - 简单来说呢，**每条数据其实都有两个隐藏字段，一个是trx_id，一个是roll_pointer：**
    - trx_id    ：**就是最近一次更新这条数据的事务id**
    - roll_pointer   ：**就是指向了你更新这个事务之前生成的undo log**。

理解如下例子：

![image-20220313190719699](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220313190719699.png)



![image-20220313190642041](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220313190642041.png)





### （2）ReadView 

ReadView 是 快照读 SQL语句执行时, MVCC 提取数据的依据。**ReadView 是一个数据结构**，

​		包含4个字段（了解）：

- `min_trx_id`：最小活跃事务 ID

- `max_trx_id`：预分配事务 ID，当前最大事务 ID+1

- `m_ids`：当前活跃的事务ID 集合

- `creator_trx_id`：`Read View`创建者 的事务 ID

  

  #### 也就是说，在访问某条记录的时候，按照`ReadView`的规则 来**判断某个版本的数据对当前事务是否可见**。

**如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。**



#### RC 和 RR 隔离级别下 Read View 的生成情况：

- `Read Committed`隔离级别：每次执行 select  时都生成一个`Read View`。
- `Read Repeatable`隔离级别：**开启事务后第一个select语句生成一个`Read View`，之后的 select 复用`Read View` 。**


　



## 4. 数据库分页查询

可使用  `LIMIT`  子句，以实现分页查询。

```sql
-- 在所有的查询结果中，返回前5行记录。 SELECT prod_name FROM products LIMIT 5;
-- 在所有的查询结果中，从第5行开始，返回5行记录。 SELECT prod_name FROM products LIMIT 5,5;
```







## 5. 聚合函数

常用的聚合函数有COUNT()、AVG()、SUM()、MAX()、MIN()。

**聚合函数自动忽略空值。**







## 6. 表和表是怎么关联的？

表与表之间常用的关联方式有两种：内连接、外连接

- 内连接：通过INNER JOIN来实现，它将返回两张表中满足连接条件的数据，**不满足条件的数据不会查询出来**。

  - <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220410161221465.png" alt="image-20220410161221465" style="zoom: 80%;" />

- 外连接：外连接通过OUTER JOIN来实现，它会返回两张表中满足连接条件的数据，**同时返回不满足连接条件的数据**。外连接有两种形式： 

  - 左外连接   ：可以简称为**左连接**（LEFT JOIN），它会**返回左表中的所有记录和右表中满足连接条件的记录**。
  - 右外连接   ：可以简称为**右连接**（RIGHT JOIN），它会**返回右表中的所有记录和左表中满足连接条件的记录**。

  > 注：哪个连接，返回哪个表中的所有数据。





## 7. WHERE和HAVING有什么区别？

- `WHERE`是一个**约束声明**，使用WHERE约束来自数据库的数据，**WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数**。

- `HAVING`是一个**过滤声明**，**是*在结果返回后之以后再对结果进行过滤*，在HAVING中可以使用聚合函数**。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。

从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。





## 8. 主从复制（了解）

MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。运用于集群

复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication的工作原理分为以下3个步骤：

1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。
3. 从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。

复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理如下图所示，其中从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。





## 9. 慢查询

在MySQL数据库中慢查询是**在日志中记录执行速度慢的SQL语句**，这个功能需要被开启才能被使用。

在Linux系统下的MySQL，配置文件一般是 /etc/my.cnf  找到[mysqld]下面加上

```json
[mysqld]

log-slow-queries=/usr/local/mysql/slowquery.log (指定日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log)
long_query_time=1 (记录超过的时间，默认为10s)
log-queries-not-using-indexes (log下来没有使用索引的query,可以根据情况决定是否开启)
log-long-format (如果设置了，所有没有使用索引的查询也将被记录)
```





## 10. MySql 索引失效

**索引失效的情况主要是针对联合索引。**

- 如下图联合索引 由 a字段 和 b字段 组成。 在第一个字段相等情况下，第二个字段是有序的。

- **索引失效的原因**：

  - **第一种情况：未遵循最左前缀原则。**

    - **遵循最左前缀原则** ：在联合索引在 B+树 上的排序，先排第一个字段，在第一个字段相等的情况下，再排第二个字段。而**第一个字段在叶子节点上有序排列，查找的时候可以通过二分查找法查找到第一个字段，在第一个字段相等情况下，第二个字段也是有序的。**
    - **不遵循最左前缀原则**：在没有第一个字段的情况下，第二个字段肯定是无序的。那就无法通过二分查找法查找到需要的值。

  - **第二种情况：范围查找 的右边索引失效，即 where 语句的右边 索引失效。**

    ```mysql
    select * from test where a > 1 and b = 1; //索引失效
    ```

    首先根据 a的索引顺序找到 a > 1 的数据，但 a > 1 对应的 b 的数据**无序**，所以无法用二分查找找到 b 的数据。

  - **第三种情况 ： 模糊查询中，% 放在 两边 或者 左边  索引失效，只有 % 放在数值右边的某些情况下 索引才会生效。**

    ```mysql
    select * from test where a like "1%";
    查 1122 ，索引生效
    查 2211 ，索引失效。此时在没有第一个字段的情况下，第二个字段肯定是无序的。那就无法通过二分查找法查找到需要的值。
    ```

    

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220412191543306.png" alt="image-20220412191543306" style="zoom:50%;" />

> - **联合索引是指对表上的多个列进行索引，**从本质上来说，联合索引还是一棵B+树，不同的是**联合索引的键值数量不是1，而是大于等于2**
> - 最左前缀原则：只有在查询条件中**使用了这些字段的左边字段时，索引才会被使用**





## 11. mybatis中#和$的区别

**#   传入的参数在   SQL  中显示为字符串，$  传入的参数在  SqL 中直接显示为传入的值**.

**# 方式能够很大程度防止sql注入，$ 方式无法防止Sql注入；**

> SQL注入 ： 语句拼接





## 12. Mysql 的数据类型

![img](https://img-blog.csdnimg.cn/img_convert/a309e1c7b8f04deda8cc5e98df3a7ada.png)

- 存时间用 DATETIME ,存储范围要更大 , **不存在时区转化问题** ；
- 存金额用decimal 类型，适合财务和货币计算的128位数据类型；
