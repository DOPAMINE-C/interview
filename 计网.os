# 0. 常识





## 1. 网络结构体系

> - **复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。**
> - 网络分层的原因：
>   - **各层之间相互独立**，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了
>   - **大问题化小**

- **`OSI`七层模型**

  > - 前三层为资源子网（数据处理），后三层为通信子网（数据通信）。
  >
  > - 传输层以上，包括传输层为 端到端通信，传输层以下三层为 点到点通信。

  <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220323190350741.png" alt="image-20220323190350741" style="zoom:50%;" />

- **`TCP/IP `四层模型** 

  是目前被广泛采用的一种模型

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220323190710742.png" alt="image-20220323190710742" style="zoom:50%;" />



- 五层模型

  > - `OSI`既复杂又不实用
  > - `TCP/IP` 网络接口层没什么新的内容
  > - 所以，一般学习计网时，采用结合了两者优点的 五层模型

  - **应用层** ：为用户提供应用功能，不用去关心数据是如何传输的

  - **传输层** ： 为**主机间进程**的通信提供数据传输服务。

    > - `TCP`协议：面向连接，可靠。`TCP `相比 `UDP` 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。
    > - `UDP`协议：无连接，不可靠。

  - **网络层** : 为**主机**提供通信服务。

    > - `IP `协议 ： 两大功能，寻址与路由。**寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**。
    >   - 寻址：为准确找到需要通信的主机，一般用` IP 地址`给设备进行编号。
    >     - `IP 地址` 又分为网络号和主机号，在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。
    >   - 路由：网络路径由很多设备连接起来，`IP`协议通过路由功能 根据 「下一个目的地」选择路径。

  - **数据链路层**：将`ip数据报`封装成帧，为网络层提供链路级别传输的服务。

    > 路由器在根据路由表找到目的`IP地址`后，需要知道 该`IP地址`属于哪个设备。而每一台设备的网卡都会有一个 `MAC 地址`，它就是用来唯一标识设备的。路由器找到目的`IP地址`后，再通过 `ARP 协议`找到 目的地的 `MAC 地址`，这样就知道这个` IP 地址`是属于哪个设备的了。

  - **物理层** ：物理层的传输单位是比特。任务是为上一层透明的传输比特流，即 二进制流。

    > 透明传输 ： 不管数据是什么比特组合，都能在链路上传输。



## 2. HTTP协议

无状态，基于TCP，本身无连接。

> - 本身无连接 ：通信双方在交换HTTP报文之前，不需要建立连接。
> - 基于TCP ：即将TCP作为传输层协议，保证了数据传输的可靠。在发送HTTP请求前，需要3次握手。
> - 无状态 ：无法记录客户端用户的状态。
>   - 好处 ：不记录状态信息，能减轻服务器的负担。
>   - 坏处 ：用户操作麻烦。如常要验证身份信息。

**超文本传输协议（HTTP，`HyperText` Transfer Protocol)**  ：主要是**为 Web 浏览器与 Web 服务器之间的通信而设计的**。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220414075702633.png" alt="image-20220414075702633" style="zoom: 80%;" />



### （1）HTTP 报文

HTTP 报文分为 请求报文 和 响应报文。

> - 请求报文 ： 从客户向服务器发送请求
> - 响应报文 ： 从服务器到客户的回答



HTTP 通信过程：

- HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：
  - 服务器在 80 端口等待客户的请求。
  - 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
  - 服务器接收来自浏览器的 TCP 连接。
  - 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
  - 关闭 TCP 连接。





#### 1. 报文结构

HTTP 报文主要有三个部分 ： 起始行 ，首部行，主体

> - 起始行 ：**请求报文 和 响应报文 的区别就在于它们的起始行不同。**
>   - 请求报文中，起始行叫 请求行
>   - 响应报文中，起始行叫 状态行
> - 首部行 ：用于说明浏览器，服务器及报文主体的一些信息。首部可以有好几行，也可以没有。**主要存放 首部字段 和 它的值。**
> - 报文主体 ：报文主体主要包含应被发送的数据。通常，不一定有报文主体。

##### Ⅰ. 请求报文

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220414080028947.png" alt="image-20220414080028947" style="zoom:67%;" />

①，②，③ 为请求行，④ 为首部行，⑤ 为报文主体。

请求行 存放了 请求方法 ，请求URL，HTTP的版本

- 请求方法：请求报文的类型是由 它采用的请求方法决定的。常用的有 Get 和 Post。

  - ***Get*** ：**请求读取 URL 标志的信息。** **安全。**

    - 如打开文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。

    <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220325104644536.png" alt="image-20220325104644536" style="zoom: 67%;" />

  - ***Post***：**给服务器添加信息**。 **不安全**，因为会修改服务器上的资源。

    - 例如在文章下留言，提交留言后，浏览器就会执行一次 POST 请求，把留言放进了报文主体 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。

      <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220414080121735.png" alt="image-20220414080121735" style="zoom:67%;" />



##### Ⅱ.响应报文

```html
HTTP/1.1 200 OK
Server: bfe/1.0.8.18
Date: Wed, 04 Apr 2018 02:39:19 GMT
Content-Type: text/html
Content-Length: 2381
Last-Modified: Mon, 23 Jan 2017 13:27:56 GMT
Connection: Keep-Alive
ETag: "588604dc-94d"
Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
Pragma: no-cache
Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
Accept-Ranges: bytes
```

状态行 存放了 HTTP的版本号，状态码，解释状态码的简单语句。

- 状态码 （Status Code）: <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 " style="zoom:50%;" />

##### Ⅲ. 常见的字段

- *Host 字段* ：在请求报文中，客户端发送请求时，用来指定服务器的域名。 如：Host: www.baidu.com，即 我（客户端）发送请求时，指定服务器域名为 百度的域名。
- *Connection 字段* ：Connection: keep-alive 时，使用 TCP 持久连接，其他请求可以复用。HTTP/1.1 版本的默认连接都是持久连接。





### （2）Cookie & Session

> - Cookie :在客户端(浏览器端)， **保存用户信息**。
> - Session :在服务器端， **通过服务端记录用户的状态**。

#### 1. Cookie

HTTP 无状态的特性，让服务器压力变小，但在实际中，影响了用户的体验。所以，在一些场景下，服务器需要记住用户的状态信息。

**一般使用Cookie 来解决HTTP 无状态 特性导致的问题。**

**`Cookie` ：通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。**即它可以记录用户的状态信息。

- 相当于，**在客户端（浏览器）第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了。**



#### 2. Session

**Session 的主要作用就是通过服务端记录用户的状态。**

- **典型的场景是购物车**，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Session 存储在服务器上，相对来说 Session 安全性更高。





### （3）`HTTPS`

HTTP 是明文传输 的，提高了可阅读性，但导致了信息不安全的问题。

> 明文传输 相当于 信息裸奔。

**可以用` HTTPS `的方式解决HTTP 的安全问题，通过在 TCP 和 HTTP 网络层之间加入了` SSL/TLS `安全协议，使得在安全上达到了极致。**

`SSL/TLS` 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 `HTTPS` 高，但是 `HTTPS` 比 HTTP 耗费更多服务器资源。

<img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层" style="zoom: 67%;" />





- HTTP  vs `HTTPS`

  - HTTP 不安全，`HTTPS` 安全。

  - HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 `HTTPS `在 TCP 三次握手之后，还需进行 `SSL/TLS `的握手过程，才可进入加密报文传输。

  - HTTP 的端口号是 80，`HTTPS` 的端口号是 443。

    

### （4） HTTP/1.0、HTTP/1.1、HTTP/2、HTTP/3 演变

- HTTP/1.0 ： 每发起一个请求，都要新建一次 TCP 连接（三次握手）。**HTTP/1.0 没有 Host字段。**

- HTTP/1.1 ： HTTP/1.1 提出了**持久连接**的通信方式。即TCP连接建立后，在一段时间内保持这段连接。**HTTP/1.1在请求头中加入了`Host`字段**

  性能缺陷：

  - 队头阻塞：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据；
  - 没有请求优先级控制；
  - 请求只能从客户端开始，服务器只能被动响应。

- HTTP/2    ： HTTP/2 协议是基于 `HTTPS `的。

  性能优化：

  - 报文格式变为 二进制，称为 帧。之前是明文报文。
  - **可以指定请求的优先级**。
  - 服务器可以主动向客户端发送消息。
  - 多路复用，可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。

- HTTP/3   ： **HTTP/3 把 HTTP 下层的 TCP 协议改成了 `UDP`！** 不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。





### （5）各种协议与 HTTP协议的关系

- **`DNS` 域名解析** ： 位于应用层。**可以将域名网址自动转换为具体的 `IP `地址。**

  > 任何一个在英特网上的主机和路由器都有一个域名。域名 可以被划分为顶级域名，二级域名，三级域名等。**越靠右**的域名表示其层级**越高**。
  >
  > - 如 ![image-20220326165358594](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220326165358594.png)

  

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与HTTP协议之间的关系" style="zoom: 80%;" />



#  重要问题



## 1. 从输入网址到网页显示，期间发生了什么？

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220414080609463.png" alt="image-20220414080609463" style="zoom: 67%;" />

- **`DNS` 域名解析** ： 位于应用层。**可以将域名网址自动转换为具体的 `IP `地址。**
- **`ARP`地址解析协议：** 位于网络层。**将`IP`地址自动换转成 `MAC`地址。**





## 2. TCP

> 简述：**TCP 主要实现 可靠传输，流量控制，拥塞控制。**
>
> - 面向连接，可靠。
> - 每条TCP连接只能有两个端点，即 TCP连接只能是点对点的，且是全双工通信。
>   - TCP 连接的端点 为 **套接字 = `IP地址 `  +   端口号**。 每条TCP连接唯一的被通信两端的两个套接字所确定。
>   - 全双工  ：  允许数据在两个方向上同时传输。 即 A 到 B，B 到 A，可以同时进行,通信双方即是发送方，也是接收方。
> - 面向字节流，TCP把应用层传下来的数据看成  一连串的 无结构字节流。即 TCP并不懂所传送的字节流的含义。
> - TCP 在发送报文时，根据 对方给出的窗口值和当前的网络拥塞情况来决定一个报文段应包含多少个字节。
>   - `UDP` 发送报文时，`UDP`用户数据报的长度是应用层给的。





### （1）TCP 报文段

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220414080847018.png" alt="image-20220414080847018" style="zoom:50%;" />

- 序列号 ： TCP是面向字节流的（TCP传送时是逐个字节传送的），所以它给传送的数据流中的每个字节都编上了一个序号。**序列号就是本报文段所发数据的第一个字节的序号。**

- 确认号 ：指期望收到对方的下一个报文段的数据的第一个字节的序号。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

- 控制位（6）：
  - ***`ACK` 确认位*：**该位为 `1` 时，**确认号字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1`** 。
  - ***SYN  同步位*：**该位为 `1` 时，**表示希望建立连接**，并在其「序列号」字段进行序列号初始值的设定。
  - ***FIN 终止位*：**该位为 `1` 时，**用来释放一个连接**。
  - ***`RST` 复原位*：**该位为 `1` 时，表示 TCP 连接中出现严重差错，必须释放连接，再重新建立连接。
  - ***`URG` 紧急位*** ：= 1 时，说明有紧急数据需要尽快传送。
  - ***`PSH` 推送位*：** = 1 时，不再等整个缓存都填满后再向上交付，尽快地交付给应用层。



### （2）TCP的可靠传输

TCP发送的报文段是交付到 `IP` 层的。但 `IP`层只能提供 不可靠的， **尽最大努力交付** 的服务，所以就需要由TCP来保证传输的可靠。

> TCP 的可靠传输主要依赖 **超时重传机制** 和 **确认机制** 实现。实际工作中，常使用 `ARQ`协议 实现可靠传输。
>
> -  `ARQ`协议 ：Auto Repeat ` reQuest ` 自动重传请求 协议。通过接收方请求 发送方重传出错的数据来恢复出错的数据。



- **超时重传机制** ：在发送数据时，设定一个定时器，当**超过指定的时间后**，**没有收到对方的 `ACK` 确认应答报文，就会重发该数据**。

  - 一般 超时时间 设置为 ***略大于`RTT`***。

    > ***`RTT`***：**数据从网络一端传送到另一端所需的时间**。`RTT`的变化在一定程度上反映了网络拥塞程度的变化

  - **快速重传** ：**当发送方收到接收方 3次同样的`ACK`时，就会触发重传机制**。



- **确认机制** ：**TCP默认使用累计确认**。**即 TCP只对按序到达的最后一个字节进行确认**，意思就是到这个字节为止的所有字节都正确收到了。如接收方收到了字节0~2，5~7，接收方将确认号`ACK`设置为3。



- **`ARQ`协议** ：通过接收方请求 发送方重传出错的数据来恢复出错的数据。分为三种：

  > 后退N帧`ARQ`  和 选择重传`ARQ `  是滑动窗口技术 和 `ARQ`协议的结合。即 连续`ARQ`协议。
  >
  > - 滑动窗口协议：TCP的滑动窗口是以字节为单位的。
  >   - 发送窗口：用来对发送方进行流量控制，发送窗口的大小表示发送方还可以发送多少字节，由接收方决定。
  >   - 接收窗口 ： 收到字节后，窗口向前移动一个位置，并返回确认。

  - **停止等待`ARQ`：**每发完一个分组就停止发送，等待对方确认（回复 `ACK`）。超时了就重传。

  

  **连续`ARQ`协议**：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

  - **后退N`ARQ` （`GBN`）:** 可以连续发送字节，累计确认。**重传 最后一个正确字节后的所有未被确认的字节。**就算原来发送过了，但接收方未返回确认（`ACK`），就需要重传。

  > - `GBN`协议会重传很多已经传过的字节，造成资源浪费。

  - **选择重传`ARQ`(SR)：** **设置单个字节确认，设置接收缓存，缓存乱序到达的字节，只重传出错的字节。** 直到所有的字节都被收到，交付给上层。然后向前移动窗口。

​			



### （3）TCP 流量控制

为什么要实现流量控制呢？

- 发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。**接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。





### （4）TCP 拥塞控制

> 拥塞：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

为什么要实现拥塞控制呢？

- 流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

  一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。

  **在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

于是，就有了**拥塞控制**，控制的目的就是**防止过多的数据注入网络**。



- 拥塞控制 vs 流量控制

  - **都是 通过控制发送方的发送速率来达到控制效果的。**

  - 拥塞控制是一个全局性的过程，而流量控制是指点对点通信量的控制。

    > 全局性过程 即涉及到所有的路由器和主机



- 怎么进行拥塞控制呢？

  为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(`cwnd`)** 的状态变量。**拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化**。发送方让自己的 ***发送窗口 =   min(拥塞窗口,接受窗口)***。



- TCP 的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。

  - **慢开始：** 何为慢开始，即先将 拥塞窗口`cwnd` = 1。每经过一个`RTT`(传输轮次)，`cwnd` 加倍。即`cwnd`指数增大。**增大到一个规定的门限值`ssthresh`，然后改用  *拥塞避免算法***。

    > ***`RTT`***：**数据从网络一端传送到另一端所需的时间**。`RTT`的变化在一定程度上反映了网络拥塞程度的变化

  - **拥塞避免算法：** **线性增大**，即 每经过一个`RTT`(传输轮次)，`cwnd` + 1。**当出现一次 超时(网络拥塞)后，令 慢开始门限值`sshresh` 等于当前 `cwnd` 的一半。**

    *快重传 和 快恢复 是对 慢开始 和 拥塞避免算法 的改进。*

  - **快重传 ： ** 当 发送方 连续收到 3 次重复的 `ACK`报文时，直接重传对方尚未收到的报文段，不用等待那个报文段设置的重传计时器超时。 即 不用像拥塞避免 那样，等到网络拥塞后，才重传。

  - **快恢复：** 将 `cwnd` 的值设置为 慢开始门限值`ssthresh` 改变后的值 (此时，`ssthresh`被拥塞避免算法变为 发送方`cwnd`的一半)，即 将 门限值 设为 原发送窗口 的一半。避免了 慢开始 `cwnd`从 1 开始的过程。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220326162539126.png" alt="image-20220326162539126" style="zoom: 80%;" />





### （5）TCP 连接

- TCP建立连接，通常称为**三次握手**。**三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

  > **最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。**

  <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220414081715448.png" alt="image-20220414081715448" style="zoom: 67%;" />

  - 第一步：客户端的TCP向服务器发送一个连接请求报文。客户端随机选择一个起始序号seq = x。

    > 连接请求报文不携带数据，但也需要消耗一个序号。

  - 第二步：若服务器同意连接，向客户端发送确认报文。确认号字段 = x + 1 代表服务器期望收到 x 报文的后一个报文。并且服务器也随机选择一个起始序号seq = y。

    > 确认报文不携带数据，但也需要消耗一个序号。

  - 第三步：客户端收到服务器的确认后，也需要回复一个确认报文。

    > 该回复确认报文可以携带数据，若不携带数据则不消耗序号。



- TCP释放连接，通常被称为**四次挥手**。

  > **数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于稳定连接(ESTABLISHED)状态，然后客户端主动关闭，服务器被动关闭。**

  <img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220326172004110.png" alt="image-20220326172004110" style="zoom:67%;" />

  - 第一步：客户端向服务器发送连接释放报文，**并停止发送数据**，主动关闭TCP连接。注意，发送了 FIN 的一端就不能再发送数据了。序号 seq = u 中的 u 代表之前发过的数据的最后一个字节序号 + 1。

    > FIN报文段即使不携带数据，也要消耗一个序号。

  - 第二步 ：服务器收到连接释放报文，发出确认报文，**服务端就进入了 关闭等待 状态**。序号 seq = v 中的 v 代表之前发过的数据的最后一个字节序号 + 1。**此时，TCP处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。**

  - 第三步：若服务器已经没有数据向客户端发送了，则**通知 客户端 释放连接**。

  - 第四步：客户端收到服务器的连接释放报文后，必须发出确认。但**此时TCP连接还未释放**，必须经过时间等待器设置的时间2`MSL`后，TCP连接才会被释放。

    > `MSL`:最长报文段寿命。
    >
    > `MSS`：最长报文段长度。













## 3. TCP 和` UDP `的区别

![TCP、UDP协议的区别](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg)

- 传输形式：
  - TCP ：面向字节流，TCP把应用层传下来的数据看成  一连串的 无结构字节流。即 TCP并不懂所传送的字节流的含义。
  - `UDP` : 面向报文，一次交付一个完整的报文。 `UDP`把应用层传下来的数据，添加首部后就交给 `IP`层。



## 4. URI 和 URL 的区别是什么?

- URI ：是统一资源标志符，**可以唯一标识一个资源**。
- URL： 是**统一资源定位符**，**可以提供该资源的路径**。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

**URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。**URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。
