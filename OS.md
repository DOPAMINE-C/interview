# 前言



## OS简述

1. **操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。**
2. **操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。** 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。
3. **操作系统存在屏蔽了硬件层的复杂性。** 操作系统就像是硬件使用的负责人，统筹着各种相关事项。
4. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

> 系统调用：在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。



## OS体系结构

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220418124429546.png" alt="image-20220418124429546" style="zoom:67%;" />





## 1.中断和异常

- 中断 ：**用户态 -> 核心态 的唯一途径。**
  - 内中断：信号来自CPU内部，与当前指令有关。也称异常
  - 外中断：信号来自CPU外部，与当前指令无关。

![image-20220418125331559](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220418125331559.png)



## 2. 系统调用

**系统调用会使CPU从 用户态 -> 核心态**

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220418130201560.png" alt="image-20220418130201560" style="zoom:50%;" />

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220418131154363.png" alt="image-20220418131154363" style="zoom:50%;" />

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220418131257364.png" alt="image-20220418131257364" style="zoom:50%;" />

1. 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。
2. 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

说了用户态和系统态之后，那么什么是系统调用呢？

​	**在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。**

这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。



## 3. 进程状态

> - PCB：进程控制块。
>
> - 进程的挂起态：**进程没有占用实际的物理内存空间 或 通过sleep 可以让进程进入挂起态**。跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。
>
>   - OS通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。
>
>     <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/9-%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA.jpg" alt="虚拟内存管理-换入换出" style="zoom: 33%;" />

一般把进程大致分为 5 种状态，这一点和线程很像！

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。阻塞态 -> 就绪态 -> 运行态
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。





## 4. 进程通信

1. 共享内存 ：**使得多个进程可以访问同一块共享内存空间**，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。但进程对共享资源的访问是**互斥的**。
2. 管道通信： **管道 就是用于连接 读写进程 的一个缓冲区。**各进程**互斥的**访问管道。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220418135056536.png" alt="image-20220418135056536" style="zoom:50%;" />

3. 消息队列 ： 进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的 “发送消息/接收消息” 两个原语进行数据交换。









# 虚拟内存

通过 **虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，**虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**。

> **虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

基于局部性原理，在程序装入时，可以**将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行**。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——**虚拟内存**。

实际上，虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。





## 虚拟内存的实现

**虚拟内存的实现需要建立在 非连续分配 的内存管理方式的基础上。**  虚拟内存的实现有以下三种方式：

> **请求分页与分页存储管理的区别：**
>
> - 请求分页存储管理建立在分页管理之上。
>
> - 它根本区别在于是否将所需的全部地址空间都装入主存。**请求分页存储管理不要求将所需的全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。**

1. **请求分页存储管理** ：**建立在分页管理之上**，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
2. **请求分段存储管理** ：**建立在分段存储管理之上**，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
3. **请求段页式存储管理**

> **缺页中断**：如果**需执行的指令或访问的数据不在内存中**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**从外存调入到内存**，然后继续执行程序；





# 内存管理

> 内存 ：用于存放数据的硬件。程序执行前，需要先放到内存中才能被CPU处理。

- 背景：单片机是没有操作系统的，每次写完代码，都需要借助工具把程序烧到板子里。并且，**单片机的 CPU 是直接操作内存的「物理地址」**。所以在单片机上同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

  - 操作系统的解决方法：**避免程序使用绝对物理地址**。即让操作系统为每个进程分配独立的一套「**虚拟地址**」，**每个进程都不能访问物理地址**。**操作系统会提供一种机制，提供了一个虚拟地址空间，将不同进程的虚拟地址和不同内存的物理地址映射起来。**

    

  - **CPU 寻址**：**将虚拟地址 -> 物理地址，从而访问到真实的物理内存。**操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。如下图所示：

    <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5-MMU%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.jpg" alt="虚拟地址寻址" style="zoom:67%;" />

    于是，这里就引出了两种地址的概念：

    - 我们程序所使用的内存地址叫做**虚拟内存地址**（*Virtual Memory Address*），比如在 C 语言中，指针里面存储的数值就是虚拟地址，虚拟地址由操作系统决定。

  - 实际存在硬件里面的空间地址叫**物理内存地址**（*Physical Memory Address*），物理地址指的是真实物理内存中的地址。



### 1. 常见的内存管理机制

> 分页管理中的页没有实际意义，仅为了满足OS内存管理的需要。而段式管理的段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。

- *连续分配管理方式*：是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。
- *非连续分配管理方式*：允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**。

1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。**将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。**

2. **分页管理** ：**把主存分为大小相等且固定的一页一页的形式，页较小**，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过 **页表** 对应逻辑地址和物理地址。

   > - **Linux 系统主要采用了分页管理**
   >
   > - **缺页中断**：如果**需执行的指令或访问的数据 不在内存中**（称为缺页或缺段），则由处理器通知操作系统将相应的 页 或 段  **调入到内存**，然后继续执行程序；
   >
   >   > 详细过程 ： 当进程访问的 **虚拟地址** 在 **页表** 中查不到时 ，CPU 向 OS 发出**缺页中断请求**，OS 进入 **内核空间** 将相应的数据 调入到物理内存中的 **空闲页** 中，并更新页表，然后返回给 **用户空间**，恢复进程的运行。
   >   >
   >   > - 页表 ： 负责 虚拟地址 和 物理地址 的转换。
   >
   > - 在分页管理中，很重要的两点 ：1. 虚拟地址到物理地址的转换要快。 2. 解决虚拟地址空间大，页表也会很大的问题
   >
   > - **优化一 ： 多级页表。** 解决虚拟地址空间大，页表也会很大的问题。 多级页表类似 多级索引
   >
   > - **优化二 ： 快表。**解决虚拟地址到物理地址的转换要快的问题。即 用一个表当作页表的Cache，其中的内容是页表的一部分或者全部内容。类似 Redis + MySQL

   <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="虚拟内存的流程" style="zoom: 50%;" />

3. **分段管理** ： 页式管理虽然提高了内存利用率，但是**页式管理其中的页实际并无任何实际意义**。 **段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息**，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

4. **段页式内存管理**：段式 + 页式。

   - **先将程序划分为多个有逻辑意义的段**，也就是前面提到的分段机制；

   - **接着再把每个段划分为多个页**，也就是对分段划分出来的连续空间，再划分固定大小的页；
   - 地址结构就由**段号、段内页号和页内位移**三部分组成。**一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号**，如图所示：
     - <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/18-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AF%BB%E5%9D%80.jpg" alt="段页式管理中的段表、页表与内存的关系" style="zoom: 50%;" />
     - 段页式地址变换中要得到物理地址须经过三次内存访问：
       - 第一次访问段表，得到页表起始地址；
       - 第二次访问页表，得到物理页号；
       - 第三次**将物理页号与页内位移组合，得到物理地址**。



# 进程管理

> 所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。
>
> - **线程是进程当中的一条执行流程。**
> - 线程与进程最大的区别在于：**线程是调度的基本单位，而进程则是资源拥有的基本单位**。



- 进程 ：我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」（Process）**。

- **进程控制块 PCB：PCB 是进程存在的唯一标识**。PCB 通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。如 就绪队列，阻塞队列。

  - PCB包含：

    **进程描述信息：**

    - 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
    - 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

    **进程控制和管理信息：**

    - 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
    - 进程优先级：进程抢占 CPU 时的优先级；

    **资源分配清单：**

    - 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

    **CPU 相关信息：**

    - CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

- 进程的控制 ：**创建、终止、阻塞、唤醒**

  - 创建 ：操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。
  - 终止 ：进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 `kill` 掉）。
  - 阻塞 ：当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。**而一旦被阻塞等待，它只能由另一个进程唤醒。**
  - 唤醒 ：进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则**只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。**

- **进程的上下文切换**

  > 常见场景：高优先级插队，进程时间片耗尽，进程被挂起

  - 各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个**一个进程切换到另一个进程运行，称为进程的上下文切换**。 CPU寄存器 + 程序计数器 = CPU上下文，进程的切换只能发生在内核态。

  - CPU寄存器 ：一个缓存。

    > 寄存器像是你的口袋，内存像你的书包，硬盘则是你家里的柜子，如果你的东西存放到口袋，那肯定是比你从书包或家里柜子取出来要快的多。

  - 程序计数器 ：存储 CPU 即将执行的下一条指令位置。

​		

# 线程

- 线程的实现

  主要有三种线程的实现方式：

  - **用户线程**：在用户空间实现的线程，不是由内核管理的线程，是**由用户态的线程库来完成线程的管理，无需用户态与内核态的切换，所以速度特别快；**
  - **内核线程**：在内核中实现的线程，是由OS管理的线程；
  - **轻量级进程**：是内核支持的用户线程，每个轻量级进程都由一个内核线程支持；



- 线程的控制： **线程控制块 TCB**
  - OS 看不到 TCB，只能看到 PCB。对于**用户线程  的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**
  - 而 对于 内核线程，**内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。**





# 调度算法

OS 的三大调度机制 ：「**进程调度/页面置换/磁盘调度算法**」

<img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%8F%90%E7%BA%B2.png" alt="本文提纲" style="zoom: 33%;" />

## 1. 进程调度算法

进程调度算法又称 CPU调度算法，因为进程是由CPU调度的。

当 CPU 空闲的时候，OS 就选择内存中的某个 【就绪态】的进程，分配给空闲CPU。

进程调度 又分为 【非抢占式调度】和 【抢占式调度】。

> - 非抢占式调度 ：不会抢CPU。运行的进程不会被打断。
> - 抢占式调度     ：可以打断运行进程，使其把CPU让给其他进程。

常见的调度算法：

- **先到先服务(FCFS)调度算法** : 每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

- **短作业优先(SJF)的调度算法** : 优先选择运行时间最短的进程来运行。

- **高响应比优先调度算法 **：权衡了短作业和长作业。**每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行**。 响应比优先级 = （等待时间 + 要求服务时间）/ 要求服务时间

  > - 等待时间相同时，要求服务时间 短 优先级高，即 短作业优先级高
  > - 要求服务时间相同时， 等待时间长 优先级高，即 长作业优先级高

- **时间片轮转调度算法** : 每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。

- **多级反馈队列调度算法** ：「时间片轮转算法」+「最高优先级算法」。

  > - 「多级」表示有多个队列，每个队列优先级从高到低，同时**优先级越高时间片越短**。
  > - 「反馈」表示 如果低优先级的队列中的进程 运行时，有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；
  > - <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt="多级反馈队列" style="zoom: 50%;" />

- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程。

  > - 静态优先级：创建进程时候，确定优先级
  > - 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级





## 2. 内存页面置换算法

「**页面置换算法**」 ： **当出现缺页异常，需调入新页面而内存已满时，选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页**

**缺页中断**：如果**需执行的指令或访问的数据 不在内存中**（称为缺页或缺段），则由处理器通知操作系统将相应的 页 或 段  **调入到内存**，然后继续执行程序；

> 详细过程 ： 当进程访问的 **虚拟地址** 在 **页表** 中查不到时 ，CPU 向 OS 发出**缺页中断请求**，OS 进入 **内核空间** 将相应的数据 调入到物理内存中的 **空闲页** 中，并更新页表，然后返回给 **用户空间**，恢复进程的运行。
>
> - 页表 ： 负责 虚拟地址 和 物理地址 的转换。
> - <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%AD%97%E6%AE%B5.png" alt="img" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.png" alt="缺页中断的处理流程" style="zoom: 50%;" />

在上述过程中，若 找不到 物理内存的空闲页，则 说明此时内存已满，这时候，就需要「**页面置换算法**」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中

常见的页面置换算法：

- 最佳页面置换算法（*OPT*）：**置换在「未来」最长时间不访问的页面**。实际系统中无法实现，因为无法预知每个页面在「下一次」访问 前的等待时间。

- 先进先出置换算法（*FIFO*）：**选择在内存中驻留时间长的页面进行置换**

- 最近最久未使用的置换算法（*LRU*）：**选择最长时间没有被访问的页面进行置换**。

- 时钟页面置换算法（*Lock*）：先进先出置换算法 + 最近最久未使用的置换算法 。 

  思想：**把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面**。

  当发生缺页中断时，算法首先检查表针指向的页面：

  - 如果**它的访问位是 0 就淘汰该页面**，**并把新的页面插入这个位置**，然后把**表针前移**一个位置；
  - 如果**访问位是 1 就 表针前移 并把 访问位改为0**，重复这个过程直到找到了一个访问位为 0 的页面为止；
  - <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟页面置换算法" style="zoom:50%;" />

- 最不常用置换算法（*LFU*）：**当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰**。实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。



## 3. 磁盘调度算法

<img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.jpg" alt="磁盘的结构" style="zoom: 80%;" />
