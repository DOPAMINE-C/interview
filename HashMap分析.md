# 一.HashMap



## HashMap 简介

​	HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是**非线程安全的**。
​	HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个
​	JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。
​	HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， **HashMap 总是使用 2 的幂作为哈希表的大小。**



## HashMap中哈希表的长度为什么是2的幂次方 

​	**因为2的n次幂-1，用二进制表示，全是1，可以用于和数组长度 &，从而得到 要存放的数据在哈希表中 对应的 数组下标，即 通过 要存放数据的 hash值 ，找到 合适的哈希桶的下标 进行存放。**&：同1异0   ； HashMap用2的幂次方做哈希表的大小，是为了得到要存放数据在哈希表中 对应的数组下标。

​	为了能让hashMap存取高效，尽量减少碰撞，也就是要尽量把数据分配均匀。**Hash值的取值范围`-2^31`到`2^31 - 1`，总共有42亿个值**，只要哈希函数映射的比较均匀，一般应用很难出现碰撞，但是内存肯定不能一次加载这么长的数组，所以这个散列值是不能拿来直接用的，我们只能创建合理长度的数组作为哈希表。

​	即**为了把 42亿个hash值，放到 n 个哈希桶里，需要创建合理长度的数组作为哈希表**。

​	方法：在插入数据之前做取模运算，得到的余数就是 要存放的数据在哈希表中 对应的 数组下标。在HashMap中这个下标的取值算法是：`(n - 1) & hash` ，n是哈希表的长度。

​	而2的n次幂-1，按二进制算，全是1：

​		![image-20220301110719974](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220301110719974.png)

​	所以取模运算中如果**除数是2的幂次方**则等价于 其与除数减一的`&`操作，就是：`hash % length == hash & (length - 1)`，即 `2^n % length` == `(2^n - 1) & length `
采用二进制位操作 `&` 相对于 `%` 能够提高运算效率，这也就解释了为啥HashMap的长度需要为2的幂次方





## 底层数据结构分析

1. `JDK1.8`前，HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。

   ​	HashMap 通过` key` 的` hashCode()` 经过 扰动函数(`hash`方法) 处理过后得到 `hash` 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度）:

   ​			如果当前位置存在元素的话，就判断该元素与要存入元素的 `hash `值以及` key` 是否相同：

   ​					如果相同的话，直接覆盖，不相同就通过*拉链法*解决冲突。

   ​	所谓*扰动函数*指的就是 HashMap 的 `hash `方法。使用 `hash `方法也就是扰动函数是为了可以减少碰撞。

   ​	`拉链法` 的实现比较简单，**将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中**即可:![image-20220301102812494](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220301102812494.png)

2. `JDK1.8`之后，当链表长度大于阈值（默认为 8）时，会首先调用 `treeifyBin()`方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。**只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。**否则，就是只是执行 `resize()` 方法对数组扩容。![img](https://oscimg.oschina.net/oscnet/up-bba283228693dae74e78da1ef7a9a04c684.png)

   ​	

   - **loadFactor 加载因子**

     loadFactor **加载因子是控制数组存放数据的疏密程度**，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加；loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。

     **loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值**。

     **给定的默认容量为 16，负载因子为 0.75。**Map 在使用过程中不断的往里面存放数据，**当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容**，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。





#  二.ConcurrentHashMap

`ConcurrentHashMap`： **线程安全的 `HashMap`**



## 1. 底层实现

### （1）JDK 1.7 : 采用 **分段的数组+链表** 实现

​		![JDK1.7的ConcurrentHashMap](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg)

如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是**数组加链表**。

**原理**：**分段锁将数据分为一段一段的存储，每一把锁只锁其中一部分数据，这样就不会存在锁竞争，提高了并发访问率。** 

**Segment 实现了 `ReentrantLock`,所以 `Segment` 是一种可重入独占锁，扮演锁的角色。`HashEntry` 用于存储键值对数据。**

但依然存在 HashMap 在 1.7 版本中的问题。

> 那就是查询遍历链表效率太低。



### （2）JDK 1.8 : **用 `Node` 数组+链表+红黑树的数据结构来实现**

​		![Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）](https://snailclimb.gitee.io/javaguide/docs/java/collection/images/java8_concurrenthashmap.png)

​	

​	**原理：去除了Segment分段锁的数据结构，而采用了 `CAS机制 + synchronized关键字` 来保证并发的安全性。也将 1.7 中存放数据的 HashEntry 改为 Node，但都用于存储键值对数据。同时为了提高哈希碰撞时的查找性能，Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）**

```txt
哈希碰撞：不同的数据计算出的hash值是一样的。
```
