# 前言

## 1.`JVM`是什么？

`JVM`全称是Java Virtual Machine（Java虚拟机）`Jvm`可以让`java`实现跨平台运行。



## 2.`JDK`,`JRE`,`JVM`的关系

1. `JDK`: ` java `development kit ,是Java 语言的开发工具包，
2. `JRE`: **` java` 运行时环境**，是 `JDK`安装目录下的一个目录，里面有两个文件夹 `bin` 和`lib`，
3. `JVM`：**是 那个 `bin`文件夹里的内容，而`lib`中则是`JVM`所需要的类库**，即 **`JVM` + `lib`  =  `JRE`**

![image-20220308155618803](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220308155618803.png)







## 3. `JVM`的位置

![在这里插入图片描述](https://img-blog.csdnimg.cn/c75dd1dd09ed4ad5b9d9becc4f4ad2c0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)



## 4. `JVM`内部工作流程

<img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690687338/9602C6323C6B86C4EDA164DB052D8420" alt="img" style="zoom: 33%;" />

**当一个类加载器 启动时，它去主机硬盘上获取字节码文件。类加载器获取了字节码文件后，放到运行时数据区的方法区中。在堆中生成一个代表该类的 Class 对象，作为方法区数据的访问入口。**





# 一.`JVM`体系结构



## 1.运行时数据区域

**注意：方法区的位置：**

1. `JDK1.8`前：永久代中，即`JVM`中。  **永久代：只有`HotSpot `类型的虚拟机才有 ，是` JVM `规范的一种实现，而方法区是` JVM `的规范**
2. `JDK1.8`后：元空间中，即本地内存中



`JDK1.8`之前：

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220421150024118.png" alt="image-20220421150024118" style="zoom:50%;" />



`JDK1.8`之后：

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220421150051352.png" alt="image-20220421150051352" style="zoom:50%;" />

总结：

1. 线程私有的：
   - 程序计数器
   - 虚拟机栈
   - 本地方法栈
2. 线程共享的：
   - 堆
   - 方法区





### 1. 程序计数器

**存放的是将要执⾏指令的地址。**

1. 区别于计算机硬件的 程序计数器，两者略有不同。

   ​	（1）计算机⽤程序计数器来存放“伪指令”或地址

   ​	（2）虚拟机的程序计数器表现为⼀块较小的内存，虚拟机的程序计数器的功能是存放将要执⾏指令的地址。

2. **字节码解释器  工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令**，从而实现代码的流程控制

3. 程序计数器是线程私有。**因为要让线程切换后能恢复到正确的执行位置**，所以**每条线程都需要有一个独立的程序计数器**

4. **程序计数器是唯一一个不会出现 `OOM` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**





### 2. 栈

![image-20220308184748845](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220308184748845.png)

#### 1. 虚拟机栈

**存放 8 ⼤ 基本类型 + 引⽤类型的变量的地址**

1）线程私有的，它的⽣命周期与线程相同，每个线程都有⼀个。

2）**每个线程创建的同时会创建⼀个`JVM`栈，`JVM栈`中每个栈帧存放的为当前线程中局部基本类型的变量，引用类型的对象在`JVM`栈上仅存放⼀个指向堆上的地址；**

3）**每⼀个⽅法从被调⽤直⾄执⾏完成的过程就对应着⼀个栈帧在虚拟机栈中从⼊栈到出栈的过程。**

4）JAVA虚拟机栈的最⼩单位可以理解为⼀个个栈帧



**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** **栈大小不够了**，若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError `错误。
- **`OutOfMemoryError`：** **内存不够用了**， Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。



#### 2. 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 服务，而本地方法栈则为虚拟机使用到的 Native(本地)方法服务。**

本地方法被执行的时候，在本地方法栈也会创建一个栈，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。





### 3. 堆

![image-20220308184741356](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220308184741356.png)

**⼀个`JVM `只有⼀个堆内存，在 `JVM`启动的时候创建**

（1）线程共享。**唯⼀⽬的就是存放对象实例**，⼏乎所有的对象实例以及数组都要在这⾥分配内存。

（2）**`java`堆也被称为“`GC`堆”**（Garbage Collected Heap）。从内存回收的⻆度来看，由于现在基本都采⽤**分代收集算法**，所以Java堆还可以细分为：新⽣代和⽼年代 ；新⽣代⼜可以分为：Eden 空间、From Survivor空间、To Survivor空间。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-整理”算法进行垃圾收集。**

***新生代采用标记-复制算法，老年代采用标记-整理算法***

（3）如果在堆中内存不够完成实例的分配，并且堆也⽆法再扩展时，将会抛出`OOM`异常。

<img src="C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220308181826138.png" alt="image-20220308181826138" style="zoom:50%;" />



### 字符串常量池 

**字符串常量池** 是` JVM` 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，**主要目的是为了避免字符串的重复创建**。**`JDK1.7 `之前,在方法区中，`JDK1.7 `之后，在堆中**。

```java
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="img" style="zoom:50%;" />







### 4. 方法区

**方法区主要用于存放编译器编译后的数据。**

![image-20220308184714730](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220308184714730.png)

**注意点：**（1）**常量池逻辑上都属于方法区 ；** 

​				（2）虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**

​				（3）**方法区是` JVM `的规范**，而 **永久代**只有`HotSpot `类型的虚拟机才有 ，是`HotSpot `类型的虚拟机` JVM `规范的一种实现。



1. 线程共享。⽅法区在`JVM`启动的时候就会被创建
2. ⽅法区的对象决定了系统可以保存多少个类,如果系统定义了太多的类导致⽅法区溢出,虚拟机同样会出`OOM`异常(`JDK1.8`之前是 `PermGen Space `(永久带) ,`JDK1.8`之后是`MetaSpace`(元空间) )。关闭`JVM`就会释放这个区域的内存。
3. **运⾏时常量池是⽅法区的⼀部分。**⽽Class⽂件中除了有类的版本、字段、⽅法、接⼝等描述信息外，还有⼀项是Class常量池，

⽤于存放编译期⽣成的 各种字⾯量 和 符号引⽤ ，这部分内容将在类加载后进⼊⽅法区的运⾏时常量池中存放。

​	既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OOM`错误





## 2. 类加载器

​	在 Java 中，**JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件）**，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

而**类加载器的作用就是加载字节码文件(.class文件)。**	**具体操作：根据给定的全限定类名(如java.lang.Object)来装载class文件的内容到运行时数据区中的方法区。在堆中生成一个代表该类的 Class 对象，作为方法区数据的访问入口。**

**数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。**非数组类才由类加载器创建

### 1. 类的加载过程

当程序主动使⽤某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进⾏初始化：**加载->连接->初始化**。

连接过程又可分为三步：**验证->准备->解析**。

![image-20220309100643283](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220309100643283.png)

详细步骤：
	（1）加载：

1. 通过全类名获取定义此类的二进制字节流 (**当一个类加载器 启动时，它去主机硬盘上获取字节码文件**)
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构（**类加载器获取了字节码文件后，放到运行时数据区的方法区中**）
3. 在堆中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口，如图

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvOTkwNTMyLzIwMTYwOC85OTA1MzItMjAxNjA4MDkxMzM3MDM5OTYtNDgyNzY0ODAxLnBuZw)

​	（2）验证

​		进行各种校验，**保证生成的类符合`JVM`规范**

​	（3）准备

​		**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**

​	（4）解析

​		解析阶段能得到类或者字段、方法在内存中的指针或者偏移量。

​	（5）初始化

​		**初始化阶段就是执行初始化方法 `<clinit> ()`方法的过程**，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

```txt
	说明： <clinit> ()方法是编译之后自动生成的。
```

​		

### 2.双亲委派机制

`JVM`在加载类时，会默认使用 **双亲委派机制**。双亲委派机制保证了 Java 程序的稳定运行，可以**避免类的重复加载**

通俗的讲，即**在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时(null 并不代表没有父类加载器)，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。若到最后都没有找到字节码文件，则报：`ClassNotFoundException`。**

双亲委派机制模型：

![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)







## 3. 执行引擎

类加载器把代码逻辑（什么时候该if，什么时候该相加，相减）都以指令的形式加载到了方法区，**执行引擎就负责执行**这些**指令**就行了。





## 4. Java本地接口(java Native Interface):

作用是调用不同语言的接口给 JAVA 用





# 二. `JVM`垃圾回收机制

Java 堆是，也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**![img](https://javaguide.cn/assets/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.c5bf5d75.png)





## 0. 什么是垃圾？怎么定义垃圾？

垃圾 ： **不再起作用，没有被引用的对象**



目前有两种算法可以用来标记垃圾：

1. **引用计数法**

   **给每个对象添加一个引用计数器**，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；**计数器为 0 时，说明该对象为垃圾对象**

   JVM 现在一般不采用这种方式，其最主要的原因是它很难解决对象之间相互**循环引用**的问题。

   举个简单的例子：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，**这两个对象再无任何引用**，实际上这两个对象已经不可能再被访问，但是**它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。**

2. **可达性分析法**

   这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为根节点出发，遍历对象引用关系图，将可以遍历(可达)的对象标记为存活，其余对象当做无用对象。**即 从 GC Roots 出发，遍历不到的节点(对象引用)，该引用对应的对象就是垃圾对象**

![81185c725aa335e21d632f1e722f1b28.png](https://img-blog.csdnimg.cn/img_convert/81185c725aa335e21d632f1e722f1b28.png)







## 1. `GC`工作流程

GC 两种类：轻GC（普通GC），重GC （全局GC）

  **轻GC** ：只针对 新生代 。**一旦Eden满了**，**触发一次Minor GC，经过这次 轻GC 后，Eden 区和 0 区已经被清空，然后“From”区和“To”区互换角色(谁空谁是 To 区)，原Survivor To成为下一次GC时的Survivor From区。总之，一次轻GC后，都会保证Survivor To区是空的**
**上述机制最大的好处就是，整个过程中，To 区是空的**

  **重GC** ：若养⽼区也满了，那么这个时候将产⽣Full GC（重GC），将整个 GC堆 全部清完。**Full GC会“Stop The World”，即在GC期间全程暂停用户的应用程序。**



​	对象都会首先在 伊甸园区 分配，在一次  **轻GC**  后，如果对象还存活，则会进入幸存区 s0 或者幸存区 s1，并且对象的年龄还会加 1(**Eden 区->Survivor 区后对象的初始年龄变为 1**)，当它的年龄增加到一定程度（**默认为大于 15 岁**），就会被晋升到老年代中。

**若养⽼区也满了，那么这个时候将产⽣Full GC（重GC）**，进⾏养⽼区的内存清理。**若养⽼区执⾏Full GC 之后发现依然⽆法进⾏对象的保存，就会产⽣`OOM`异常“OutOfMemoryError”。** 

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221110554763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1ODU1Ng==,size_16,color_FFFFFF,t_70)









## 2. 垃圾回收算法

### 0. HotSpot 为什么要分为新生代和老年代？

当前虚拟机的垃圾收集都采用分代收集算法，一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

**比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-整理”算法进行垃圾收集。**

***新生代采用标记-复制算法，老年代采用标记-整理算法***



### 1. 标记清除算法

![image-20220309164945235](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220309164945235.png)



### 2. 标记复制算法

**将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。**

![image-20220309165452179](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220309165452179.png)

好处：没有内存的碎片
坏事：浪费一半内存的空间



### 3.标记整理法

是标记清除算法和标记复制算法的优化

⾸先**遍历整个空间对可达对象进⾏标记，然后再将所有可达对象整理到⼀起去，最后清除掉不可达的对象**，达到GC回收清理内存的⽬的。

![image-20220309165845797](C:\Users\51\AppData\Roaming\Typora\typora-user-images\image-20220309165845797.png)





##  3. 垃圾收集器(了解)

**如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

JVM具有四种类型的*GC*实现：

- 串行垃圾收集器
- 并行垃圾收集器
- **CMS垃圾收集器**
- **G1垃圾收集器**





### （1）Serial 收集器：单线程，STW

​	Serial（串行）收集器只会使用一条垃圾收集线程去完成垃圾收集工作，并且在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

![ Serial 收集器 ](https://javaguide.cn/assets/46873026.3a9311ec.png)

### （2）ParNew 收集器：多线程版 Serial 收集器

​	ParNew 收集器其实就**是 Serial 收集器的多线程版本**

![ParNew 收集器 ](https://javaguide.cn/assets/22018368.df835851.png)



### （3） CMS 收集器：并发收集器

​	**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的并发收集器**。

​	从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 **"GC Roots"** 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![CMS 垃圾收集器 ](https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png)



### （4）G1 收集器

​	G1 (Garbage-First) 是一款**面向服务器的垃圾收集器**,以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.







# 三.重点问题



## 1. 为什么要把永久代替换成元空间呢？

1. 为了降低`OOM`的出现。**永久代的大小无法调整，而元空间使用的是本地内存，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。**
2. 元空间里面存放的是类的元数据，使用元空间可以加载更多的类





## 2. 字符串常量池的位置

1. `JDK1.7 `之前运行时常量池逻辑包含字符串常量池**存放在方法区**, **此时 `hotspot` 虚拟机对方法区的实现为永久代**
2. `JDK1.7` 字符串常量池被**从方法区拿到了堆中**, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 `hotspot` 中的永久代 。
3. `JDK1.8`中 `hotspot` 移除了永久代用元空间(`Metaspace`)取而代之, 这时候**字符串常量池还在堆**, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(`Metaspace`)

**常量池逻辑上都属于方法区 ；** 





## 3.Java 程序是怎么运行的

写好的 Java 源代码文件经过 Java 编译器编译成字节码文件后，通过类加载器加载到内存中，才能被实例化，然后到 Java 虚拟机中解释执行，最后通过操作系统   操作 CPU 执行获取结果。类加载器根据给定的全限定类名(如java.lang.Object)来装载class文件的内容到运行时数据区中的方法区。在堆中生成一个代表该类的 Class 对象，作为方法区数据的访问入口。如下图：

![img](https://img-blog.csdn.net/20160704105123079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)





## 4.Java 对象的实例化过程

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645690800773/9285BA6FB2D1E24A711E876B40F6E978)





## 5. 为什么要设置两个Survivor区域？

设置两个 Survivor 区最大的好处就是**能保证永远都有一个幸存区是空的，另一个非空的 Survivor space 是无碎片的。**









## 6. 内存泄漏和内存溢出有什么区别？

内存泄漏（memory leak）：**内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序**，好像是内存泄漏出去了，于是就发生了内存泄漏。

内存溢出（out of memory）：简单地说内存不够用了，于是就发生了内存溢出。







## 7. 什么是内存溢出，怎么解决？

内存溢出（out of memory）：简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。

引起内存溢出的原因有很多种，常见的有以下几种：

1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
2. 集合类中有对 对象的引用，使用完后未清空，使得JVM不能回收；
3. 代码中存在死循环或循环产生过多重复的对象实体；
4. 使用的第三方软件中的BUG；
5. 启动参数内存值设定的过小。



内存溢出的解决方案：

- 第一步，**修改堆的大小( -Xms , -Xmx)，直接增加内存。**
- 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
- 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
- 第四步，**使用 内存分析器 (`Jprofiler`) 动态查看内存使用情况。**





## 8.哪些区域会OOM，怎么触发OOM？

​	**除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。**

1. **Java堆溢出**

   Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

2. **虚拟机栈和本地方法栈溢出**

   HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。

3. **方法区和运行时常量池溢出**

   方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。这类场景常见的包括：程序使用了CGLib字节码增强和动态语言、大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。

   在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，即常量池是方法去的一部分，所以上述问题在常量池中也同样会出现。而HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代，所以上述问题在JDK 8中会得到避免。

4. **本地直接内存溢出**

   直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。如果直接通过反射获取Unsafe实例进行内存分配，并超出了上述的限制时，将会引发OOM异常
